// // Date: 25.12.2015 00:50:09
// // Template version 1.1
// // Java generated by Techne
// // Keep in mind that you still need to fill in some blanks
// // - ZeuX

// package com.hbm_m.client.render.legacy;

// import org.lwjgl.opengl.GL11;

// import com.hbm_m.client.model.HbmModelRenderer;
// import com.mojang.blaze3d.vertex.PoseStack;
// import com.mojang.blaze3d.vertex.VertexConsumer;

// import net.minecraft.client.model.HumanoidModel;
// import net.minecraft.client.model.geom.ModelPart;
// import net.minecraft.client.model.geom.builders.CubeDeformation;
// import net.minecraft.client.model.geom.builders.CubeListBuilder;
// import net.minecraft.client.model.geom.builders.LayerDefinition;
// import net.minecraft.client.model.geom.builders.MeshDefinition;
// import net.minecraft.world.entity.LivingEntity;


// public class ModelT45Boots extends HumanoidModel<LivingEntity> {

// 	HbmModelRenderer leftleg;
// 	HbmModelRenderer rightleg;
// 	HbmModelRenderer Shape1;
// 	HbmModelRenderer Shape2;
// 	HbmModelRenderer Shape3;
// 	HbmModelRenderer Shape4;

//     int textureWidth = 64;
//     int textureHeight = 32;

// 	public ModelT45Boots() {
//         super(root);

// 		this.leftleg = new HbmModelRenderer(0, 0);
// 		this.rightleg = new HbmModelRenderer(0, 0);
// 		this.Shape1 = new HbmModelRenderer(0, 0);
// 		this.Shape1.addBox(0F, 0F, 0F, 4, 2, 6);
// 		this.Shape1.setRotationPoint(-4F + 2, 0F + 9.5F, -4F);
// 		this.Shape1.mirror = true;
// 		setRotation(this.Shape1, 0F, 0F, 0F);
// 		convertToChild(this.leftleg, this.Shape1);
// 		this.Shape2 = new HbmModelRenderer(0, 8);
// 		this.Shape2.addBox(0F, 0F, 0F, 4, 2, 6);
// 		this.Shape2.setRotationPoint(0F - 2, 0F + 9.5F, -4F);
// 		this.Shape2.mirror = true;
// 		setRotation(this.Shape2, 0F, 0F, 0F);
// 		convertToChild(this.rightleg, this.Shape2);
// 		this.Shape3 = new HbmModelRenderer(0, 16);
// 		this.Shape3.addBox(0F, -1F, 0F, 4, 2, 4);
// 		this.Shape3.setRotationPoint(-4F + 2, 0F + 9.5F, -4F);
// 		this.Shape3.mirror = true;
// 		setRotation(this.Shape3, 0.2617994F, 0F, 0F);
// 		convertToChild(this.leftleg, this.Shape3);
// 		this.Shape4 = new HbmModelRenderer(0, 22);
// 		this.Shape4.addBox(0F, -1F, 0F, 4, 2, 4);
// 		this.Shape4.setRotationPoint(0F - 2, 0F + 9.5F, -4F);
// 		this.Shape4.mirror = true;
// 		setRotation(this.Shape4, 0.2617994F, 0F, 0F);
// 		convertToChild(this.rightleg, this.Shape4);
// 	}

//     // Метод для Forge регистрации слоя (пустой, т.к. мы юзаем HbmModelRenderer)
//     public static LayerDefinition createBodyLayer() {
//         MeshDefinition mesh = HumanoidModel.createMesh(CubeDeformation.NONE, 0.0F); // Пустой меш
//         return LayerDefinition.create(mesh, 64, 32);
//     }

//     @Override
//     public void setupAnim(LivingEntity entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch) {
//         // Вызываем ванильную анимацию (она повернет this.leftLeg, this.rightLeg и т.д.)
//         super.setupAnim(entity, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch);
        
//         // Копируем анимацию из ванильных частей в наши Hbm части
//         copyProperties(this.leftLeg, this.leftleg);
//         copyProperties(this.rightLeg, this.rightleg);
        
//         // Корректировка позиции для сникинга (в ваниле это делается автоматически в render, но тут можно уточнить)
//         if (this.crouching) {
//             this.leftleg.rotationPointY += 3.0F; // Примерные значения
//             this.rightleg.rotationPointY += 3.0F;
//         }
//     }

// 	@Override
// 	public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entity) {

// 		this.isSneak = entity.isSneaking();
// 		this.isRiding = entity.isRiding();

// 		super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entity);

// 		this.leftleg.rotationPointX = this.bipedLeftLeg.rotationPointX;
// 		this.leftleg.rotationPointY = this.bipedLeftLeg.rotationPointY - 1.5F;
// 		this.leftleg.rotationPointZ = this.bipedLeftLeg.rotationPointZ;
// 		this.leftleg.rotateAngleX = this.bipedLeftLeg.rotateAngleX;
// 		this.leftleg.rotateAngleY = this.bipedLeftLeg.rotateAngleY;
// 		this.leftleg.rotateAngleZ = this.bipedLeftLeg.rotateAngleZ;
// 		this.rightleg.rotationPointX = this.bipedRightLeg.rotationPointX;
// 		this.rightleg.rotationPointY = this.bipedRightLeg.rotationPointY - 1.5F;
// 		this.rightleg.rotationPointZ = this.bipedRightLeg.rotationPointZ;
// 		this.rightleg.rotateAngleX = this.bipedRightLeg.rotateAngleX;
// 		this.rightleg.rotateAngleY = this.bipedRightLeg.rotateAngleY;
// 		this.rightleg.rotateAngleZ = this.bipedRightLeg.rotateAngleZ;

// 		if (this.isSneak) {
// 			this.leftleg.rotationPointZ -= 0.5F;
// 			this.rightleg.rotationPointZ -= 0.5F;
// 			this.leftleg.rotationPointY += 0.5F;
// 			this.rightleg.rotationPointY += 0.5F;
// 		}
// 	}

// 	@Override
// 	public void render(Entity entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor) {

// 		this.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entity);

// 		GL11.glPushMatrix();
// 		GL11.glScalef(1.125F, 1.125F, 1.125F);
// 		// this.leftleg.addChild(Shape1);
// 		// this.leftleg.addChild(Shape3);
// 		this.leftleg.render(scaleFactor);

// 		// this.rightleg.addChild(Shape2);
// 		// this.rightleg.addChild(Shape4);
// 		this.rightleg.render(scaleFactor);
// 		GL11.glPopMatrix();
// 	}

//     @Override
//     public void renderToBuffer(PoseStack poseStack, VertexConsumer buffer, int packedLight, int packedOverlay, float red, float green, float blue, float alpha) {
//         // Рендерим наши части
//         // Масштаб (1.125F) из старого кода применяем через PoseStack
//         poseStack.pushPose();
//         poseStack.scale(1.125F, 1.125F, 1.125F); // GL11.glScalef(1.125F...)
        
//         this.leftleg.render(poseStack, buffer, packedLight, packedOverlay);
//         this.rightleg.render(poseStack, buffer, packedLight, packedOverlay);
        
//         poseStack.popPose();
//     }

// 	// === Хелперы ===
    
//     private void copyProperties(ModelPart vanilla, HbmModelRenderer hbm) {
//         hbm.rotateAngleX = vanilla.xRot;
//         hbm.rotateAngleY = vanilla.yRot;
//         hbm.rotateAngleZ = vanilla.zRot;
//         hbm.rotationPointX = vanilla.x;
//         hbm.rotationPointY = vanilla.y;
//         hbm.rotationPointZ = vanilla.z;
//     }

//     protected static void convertToChild(HbmModelRenderer parent, HbmModelRenderer child) {
//         child.rotationPointX -= parent.rotationPointX;
//         child.rotationPointY -= parent.rotationPointY;
//         child.rotationPointZ -= parent.rotationPointZ;
//         child.rotateAngleX -= parent.rotateAngleX;
//         child.rotateAngleY -= parent.rotateAngleY;
//         child.rotateAngleZ -= parent.rotateAngleZ;
//         parent.addChild(child);
//     }

//     private static void setRotation(HbmModelRenderer model, float x, float y, float z) {
//         model.rotateAngleX = x;
//         model.rotateAngleY = y;
//         model.rotateAngleZ = z;
//     }
// }
